&emsp; &emsp;所谓的计算机网络就是一个大的**协议**规则，用户通过这些协议将用户数据传递到实际的物理链路上进行传输，到达指定的地址后，再进行一层层的协议解析获得用户的数据。

---
### 1.1 计算机网络体系结构
&emsp; &emsp;计算机网络是计算机相互连接的基础，是一组组定义的不同设备与层之间的**协议**。不同的标准对网络体系结构的定义是不同的。标准网络体系分为七层结构：
![[../picture/Pasted image 20240317232914.png#pic_center|560]]
&emsp;&emsp;&emsp; ① **应用层**：通过**应用进程间的交互**来完成特定网络应用。**应用层协议定义是应用进程间通信和交互的规则**。应用层交互的数据单元是**报文**。 
&emsp;&emsp;&emsp; ② **运输层**：两台主机中，进程间的通信的**通用数据传输服务**。运输层协议主要有两种：
&emsp;&emsp; &emsp; &emsp;`TCP`(Transmission Control Protocol)传输控制协议-面向连接的可靠的数据报文段。 
&emsp;&emsp; &emsp; &emsp;`UDP`(User Datagram Protocol)用户数据报协议-无连接的最大努力交付的用户数据报。 
&emsp;&emsp;&emsp; ③ **网络层(IP层)**：把运输层缠身的报文段或用户数据报封装成分组(IP数据报)或包进行传送，同时选择合适的路由，使运输层传输下来的分组能够通过路由器找到目的主机。 
&emsp;&emsp;&emsp; ④ **链路层**：将网络层的IP数据报组装成帧，每一帧包括数据和必要的控制信息。 
&emsp;&emsp; &emsp;⑤ **物理层**：实际的传输线路，按0，1比特位发送。

![[../picture/Pasted image 20240319130456.png#pic_center|660]]

![计算机网络协议](https://img-blog.csdnimg.cn/20200208104429940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk2Mzk2OQ==,size_16,color_FFFFFF,t_70)

---
### 1.2 网络层
&emsp; &emsp;网络层是计算机网络体系结构中的一层，位于传输层和数据链路层之间。网络层实现了数据包的选路和转发。在两个主机通信时，不是直接相连的，而是通过多个中间结点(路由器)连接的。网络层的任务就是针对目标IP地址 ，选择这些中间节点，确定两个主机之间的通信路径，选择合适的路由，使运输层传输下来的分组能够通过路由器找到目的主机。

&emsp; &emsp;网络层的主要功能包括：
&emsp;&emsp;&emsp; ① **IP地址分配和路由选择**：网络层使用IP (Internet Protocol) 地址来唯一标识网络中的主机和路由器。它负责将数据包根据目标IP地址进行路由选择，以确定数据包的最佳路径。
&emsp;&emsp;&emsp; ② **分组封装和解封**：网络层将传输层的数据报封装为数据包 (IP数据包)，并添加源和目标IP地址以及其他必要的控制信息。在目标主机上，网络层负责解封数据包并将其传递给传输层。
&emsp;&emsp;&emsp; ③ **网络互连**：网络层通过路由器和交换机等网络设备将多个网络连接起来，实现不同网络之间的互连。数据包可以在不同网络之间传输，从而实现全球范围的通信。
&emsp;&emsp;&emsp; ④ **路由和转发**：网络层使用路由选择算法来确定数据包的最佳路径，以实现快速而可靠的数据传输。路由器是网络层的关键设备，它们根据目标IP地址和路由表中的信息来转发数据包。
&emsp;&emsp;&emsp; ⑤ **IP协议**：网络层使用IP协议来定义数据包的格式、传输方式和错误处理等细节。IPv4 (Internet Protocol version 4) 和 IPv6 (Internet Protocol version 6) 是目前最常用的IP协议版本。

&emsp; &emsp;网络层提供了两种主要的服务：
&emsp;&emsp;&emsp;① 数据报服务( Datagram Service )
&emsp;&emsp;&emsp;  数据报服务是网络层提供的一种**无连接的、不可靠的**服务。在数据报服务中，每个数据包 (也称为数据报) 独立地传输，没有建立和维护持久的通信连接。每个数据报都包含了完整的源和目标地址信息，使得网络层能够根据目标地址将数据包路由到正确的目标主机。数据报服务适用于需要快速而简单的数据传输场景，如互联网上的IP数据包传输。数据报服务具有以下特点：
&emsp;&emsp;&emsp; ● 灵活性：数据报服务是一种无连接的服务，每个数据包都是独立的实体，可以按需发送和接收。这种灵活性适用于对实时性要求高、传输内容不需要按顺序到达的应用。
&emsp;&emsp;&emsp; ● 简单性：数据报服务不需要在通信之前建立连接，减少了通信的开销和延迟。它适用于短暂的、一次性的通信，无需额外的连接建立和管理。
&emsp;&emsp;&emsp; ● 适应性：数据报服务可以适应网络中的动态变化，例如，可以通过路由选择算法根据当前的网络拓扑和负载情况动态选择传输路径。

&emsp;&emsp;② 虚电路服务 ( Virtual Circuit Service )
&emsp;&emsp;&emsp;  虚电路服务是网络层提供的一种**有连接的、可靠的**服务。在虚电路服务中，通信的两个端点在通信之前先建立一个虚电路，然后通过该虚电路进行数据传输。<font color=green>虚电路是一条逻辑上的通信路径，由网络中的路由器和交换机维护</font>。在建立虚电路时，网络层会分配一个唯一的标识符 ( 虚电路号 )来识别该虚电路。虚电路服务提供了可靠的数据传输，可以进行拥塞控制和差错纠正等机制，适用于对数据可靠性要求较高的应用，如传统的电路交换网络和虚拟专用网络 (VPN)。虚电路服务具有以下特点：
&emsp;&emsp;&emsp; ●  可靠性：虚电路服务提供了可靠的数据传输机制，包括拥塞控制、差错纠正和丢包重传等。通过在建立虚电路时进行资源分配和路径规划，虚电路服务可以确保数据按照预定的顺序、可靠地到达目标主机。如文件传输和大规模数据传输。
&emsp;&emsp;&emsp; ●  效率性：虚电路服务可以通过建立和维护虚电路来优化数据传输效率。一旦虚电路建立完成，后续的数据传输可以利用已经建立的通信路径，避免了每个数据包都进行路由选择的开销。
&emsp;&emsp;&emsp; ●  有序性：虚电路服务可以保证数据按照发送的顺序到达目标主机。例如，实时语音通信中要求按照顺序接收和播放音频数据。

![[../picture/Pasted image 20240320131639.png#pic_center|500]]

#### 1.2.1 网络层协议
&emsp;&emsp;在网络层存在4个主要的协议： 网际IP协议 ( Internet Protocol)、 地址解析协议ARP (Address Resolution Protocol)、 网际控制报文协议ICM P(Internet Control Message Protocol) 、 网际组管理协议IGMP (Internet Group Management Protocol)
##### 1.网际IP协议 - 数据报文协议
&emsp;&emsp;IP协议是网络层的基础，IP协议定义了数据包的格式、传输方式、路由选择和错误处理等细节，使得数据能够在不同的网络之间进行传输和交换。IP协议的主要特点和功能包括：
&emsp;&emsp;&emsp;① 唯一标识：IP协议使用IP地址来唯一标识网络中的主机和路由器。IPv4地址由32位二进制数表示，通常以点分十进制表示(例如，192.168.0.1)，而IPv6地址由128位二进制数表示，以冒号分隔的十六进制表示 (例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334)。IP地址允许主机和路由器在网络中进行识别和寻址。
&emsp;&emsp;&emsp;② 分组传输：IP协议将数据分割为较小的数据包 (也称为IP数据报或数据包)，并在每个数据包中添加IP头部信息。每个数据包独立传输，可以通过不同的路径和中间节点进行传输，从源主机到目标主机经过一系列的路由器。
&emsp;&emsp;&emsp;③ 路由转发与数据交付：IP协议使用路由选择算法来确定数据包的最佳路径。路由选择是根据目标IP地址和路由表中的信息进行的，每个路由器根据自己的路由表选择下一跳，并将数据包转发到适当的接口，最终根据目标主机的IP地址将数据包交付给目标主机的网络层。
&emsp;&emsp;&emsp;④ 无连接性：IP协议是一种无连接的协议，每个数据包都是独立的实体。它不需要在通信之前建立和维护持久的连接，减少了通信的开销和延迟。
&emsp;&emsp;&emsp;⑤ 不可靠性：IP协议本身是不可靠的，它没有提供数据传输的可靠性保证。如果发生数据包的丢失、重复、损坏或乱序，IP协议本身没有机制来纠正或处理这些问题。这些问题通常由上层的传输层协议 (如TCP) 来解决。

###### (1). IP数据报
&emsp;&emsp; 一个IP数据报由首部和数据两部分组成。首部的前一部分长度是固定的，共20字节，是所有IP数据报必须具有的。在首部固定部分的后面是一些可选字段，其长度是可变的。
![[../picture/Pasted image 20240327232907.png#pic_center|550]]
&emsp;&emsp;&emsp;●  **版本**：占4位，指IP协议的版本。通信双方使用IP协议的版本必须一致。两种版本：IPv4 和 IPv6
&emsp;&emsp;&emsp;● **首部长度**：占4位，可表示的最大十进制数值是15(1111)，首部长度的单位是32位字长(4字节)，即0001 -> 首部长度为4字节。由于IP首部的固定部分是20字节，因此首部长度字段的最小值是5(0101)。当首部长度字段为最大值1111时，首部长度最大为60字节。IP头部最少20个字节，最多60个字节。
&emsp;&emsp;&emsp;● **区分服务**：占8位，只有在使用区分服务时，这个字段才起作用
&emsp;&emsp;&emsp;● **总长度**：总长度指首部和数据之和的长度，此数据报的总长度不能超过下面的数据链路层所规定的MTU值，否则就需要对数据报进行分片传输。
&emsp;&emsp;&emsp;● **标识**：IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。当数据报由于长度超过网络的MTU而必须分片时，这个标识字段的值就被复制到每个对应的的数据报片的标识字段中，使分片后的各数据报片最后能正确地重装成为原来的数据报。
&emsp;&emsp;&emsp;●**标志**：占3位
&emsp;&emsp;&emsp;  -> 最低位记为MF(More Fragment)。  MF=1即表示后面“还有分片”的数据报。  MF=0表示这已是若干数据报片中的最后一个。
&emsp;&emsp;&emsp;  -> 标志字段中间的一位记为DF(Don’t Fragment)，意思是“不能分片”。  只有当DF=0时才允许分片。
&emsp;&emsp;&emsp;  -> 最高位目前没有意义。
&emsp;&emsp;&emsp;●**片偏移**：较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位，除最后一个数据报片外，其他每个分片的长度一定是8字节(64位)的整数倍。
![[../picture/Pasted image 20240328132405.png#pic_center|650]]
&emsp;&emsp;&emsp;●**生存时间**：占8位，即TTL(Time To Live)，TTL是数据报在网络中的寿命。TTL由发出数据报的源点设置，其目的是防止无法交付的数据报无限制地在互联网中传输，因而白白消耗网络资源。TTL的意义是指明数据报在互联网中至多可经过多少个路由器。 路由器在每次转发数据报之前就把TTL值减1。若TTL值减小到零，就丢弃这个数据报，不再转发。因此，TTL的单位是跳数。数据报能在互联网中经过的路由器的最大数值是255。若把TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送。
&emsp;&emsp;&emsp;●**协议**：占8位，协议字段指出此数据报携带的数据使用何种协议，以便使目的主机的IP层知道应将数据部分交给哪个协议进行处理。
&emsp;&emsp;&emsp;●**首部检验和**：占16 位，首部检验和的主要作用是接收方和网关用来校验数据有没有被改动过。首部检验和**只检验数据报的首部，不包括数据部分**。数据报每经过一个路由器，路由器都要重新计算一下首部检验和。

###### (2). IP地址
**▨ IP地址与MAC (硬件) 地址**

&emsp;&emsp; IP地址和硬件地址是网络中用于唯一标识设备的两种不同类型的地址。
&emsp;&emsp;&emsp;● **IP地址 (Internet Protocol Address)** ：是在网络层使用的逻辑地址，用于在互联网上唯一标识设备和网络接口。IP地址是由32位 (IPv4) 或128位 (IPv6) 的二进制数字组成，通常以点分十进制的形式表示。IP地址用于寻址和路由数据包在网络中的传输。
&emsp;&emsp;&emsp;● **MAC 地址 (Media Access Control Address)**：也称为物理地址或硬件地址，是在数据链路层使用的地址。硬件地址是一个由48位二进制数字组成的唯一标识符，通常以冒号分隔的十六进制形式表示。每个网络接口 (如网卡) 都有一个唯一的硬件地址，用于在局域网 LAN 上识别设备。
><font color=SlateBlue>  <u>**Q1. 有了 MAC 地址为什么还要有 IP 地址 ？**</u></font>
>&emsp;&emsp;&emsp;IP地址和硬件地址在网络通信中扮演不同的角色。当数据从源设备发送到目标设备时，数据包的源IP地址和目标IP地址用于确定数据包的源和目标位置。而数据链路层使用硬件地址来识别数据包的源和目标设备，以便在局域网中直接传输数据帧。
>
>![[../picture/Pasted image 20240401231301.png#pic_center|380]]
>&emsp;&emsp;&emsp;● <font color=green>IP地址**用于逻辑寻址和路由**</font>，标识设备在互联网上的位置。它指示数据包应该从源设备发送到目标设备的路径。IP地址可以被动态分配、配置和更改，允许设备在不同网络中移动，并与其他网络中的设备通信。
>&emsp;&emsp;&emsp;● <font color=green>硬件地址**用于局域网内部的设备识别**</font>。它用于在同一局域网中直接发送数据包，而不需要通过路由器进行转发。硬件地址是设备出厂时固定的，无法更改。它在局域网中用于直接通信和数据帧传输的识别。


**▨ IP地址分类**

&emsp;&emsp; IP地址是网络中的主机和路由器的唯一标识，根据网络规模大小，IP地址可以将其分为以下几类：A类、B类、C类、D类和E类。
&emsp;&emsp;&emsp;● A类地址：A类地址是用于大规模网络的地址类别。它的第一个字节范围是1~126，用于标识网络部分，而剩下的三个字节用于标识主机部分。A类地址的前8位固定为0，即网络地址的最高位为0。A类地址可以分配给具有大量主机的大型组织或公司。
&emsp;&emsp;&emsp;● B类地址：B类地址适用于中等规模网络。它的第一个字节范围是128~191，用于标识网络部分，后面两个字节用于标识主机部分。B类地址的前16位固定为10，即网络地址的最高两位为10。B类地址可以分配给中等规模的组织或公司。
&emsp;&emsp;&emsp;● C类地址：C类地址适用于小规模网络。它的第一个字节范围是192~223，用于标识网络部分，后面的三个字节用于标识主机部分。C类地址的前24位固定为110，即网络地址的最高三位为110。C类地址可以分配给小规模的组织或公司。
&emsp;&emsp;&emsp;● D类地址：D类地址用于多播 (Multicast) 通信。它的第一个字节范围是224~239，用于标识多播组。D类地址用于将数据报发送给一组特定的主机，而不是单个主机。
&emsp;&emsp;&emsp;● E类地址：E类地址是保留地址，用于实验和研究目的。它的第一个字节范围是240~255。E类地址并没有被广泛使用，并且不用于常规的网络通信
![[../picture/Pasted image 20240330101430.png#pic_center|500]]

&emsp;&emsp; 由于互联网中的网络大小是不固定的，当采用五类地址划分时，可能会造成IP地址的浪费和不均匀分配，也会对IP的转发造成压力。因此IP地址的寻址和编码通常采用CIDR方式(无类域间路由)。CIDR引入了**可变长度子网掩码**(VLSM)，使用前缀长度来表示IP地址的网络部分的位数。CIDR使用一个**斜线后跟一个数字**来表示前缀长度。例如，`192.168.0.0/16`表示前16位为网络部分，剩余的位数为主机部分。

###### (3). IP层转发分组的流程

&emsp;&emsp; IP层的转发分组是基于**分组首部中的目的地址**的转发。分组每到达一个路由器，路由器就根据分组中的终点(目的地址)查找转发表，然后得知下一跳应当到哪一个路由器。由于互联网中的主机数目太大，而网络数远远小于主机数，因此在查找目的地址时，通常**先查找目的网络(网络前缀)，在找到了目的网络之后，再查询这个网络上的目的主机**。这样就可以压缩路由器中转发表的大小，加速分组在路由器中的转发。
&emsp;&emsp;&emsp;  当路由器收到一个待转发的分组，在从转发表得出下一跳路由器的IP地址后，不是把这个地址填入分组首部，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的IP地址转换成MAC地址(使用ARP)，并将此MAC地址放在链路层的MAC帧的首部，然后利用这个MAC地址传送到下一跳路由器的链路层，再取出MAC帧的数据部分，交给网络层。
![[../picture/Pasted image 20240330115041.png#pic_center|460]]
![[../picture/Pasted image 20240330110310.png#pic_center|540]]
&emsp;&emsp;&emsp;① **接收分组**：路由器作为网络层设备，接收到来自上层或下层的IP数据分组。该分组通常包含源IP地址和目标IP地址
&emsp;&emsp;&emsp;② **查找路由表并匹配下一跳**： 路由器根据接收到的分组中的目标IP地址，与路由表中的目标网络进行匹配。这通常是通过与目标网络的IP地址范围进行比较来实现的。
&emsp;&emsp;&emsp; ● 源主机H1要发送的分组的目的地址是128.1.2.132，本网络`128.1.2.192/26`的前缀有26位。将目的地址和子网掩码按位AND运算，结果与转发表第一行的前缀不匹配。
&emsp;&emsp;&emsp; ● 接着检查路由器R的转发表中的第2行。AND运算运算结果是128.1.2.128/26，与转发表第2行前缀相匹配。因此按照转发表第2行在网络 Net2 上进行分组交付。这时路由器R1调用ARP，解析出目的主机H2的 MAC 地址，再封装成链路层的帧，直接交付连接在本网络 Net2 上的目的主机。
&emsp;&emsp;&emsp;③ **转发分组**：路由器将分组发送到确定的下一跳路由器。它会将分组从接收接口读取，并在发送接口上进行转发。在转发过程中，路由器会重新计算校验和和TTL（生存时间）字段，并更新相应的值。
&emsp;&emsp;&emsp;④ **循环或丢弃检测**：在转发过程中，路由器可能会执行一些循环检测和丢弃判断。例如，它可以检查分组的TTL字段是否已经减少为零，如果是，则丢弃分组。这可以防止分组在网络中无限循环。
&emsp;&emsp;&emsp;⑤ **到达目标网络**：分组最终到达目标网络中的下一跳路由器。下一跳路由器会根据自己的路由表，继续重复上述流程，直到分组到达目标主机。
&emsp;&emsp;&emsp;⑥ **交付给上层**：一旦分组到达目标主机，目标主机的网络层将处理该分组，可能涉及上层协议（如TCP或UDP）的处理。

&emsp;&emsp;在采用 CIDR 编址时，如果一个分组在转发表中可以找到多个匹配的前缀，那么就应当选择前缀最长的一个作为匹配的前缀。这个原则称为<font color=red>**最长前缀匹配**</font>(longest prefixmatch)。网络前缀越长，其地址块就越小，因而路由就越具体。为了更加迅速地查找转发表，可以按照前缀的长短，把前缀最长的排在第1行，然后按前缀长短的顺序往下排列。

##### 2.ICMP协议 -  控制报文协议
&emsp;&emsp; 网际控制报文协议 (Internet Control Message Protocol，ICMP) 是一种用于在IP网络中**传输控制信息**的协议。ICMP是依靠 IP 协议来完成信息发送的，它是 IP 的主要部分。ICMP 主要用于检测网络连接、诊断网络问题以及提供错误报告。ICMP 消息通常由网络设备 (如路由器) 或网络应用程序生成，并在网络中传输。 ICMP 主要有以下两个功能：
&emsp;&emsp;&emsp;① **确认 IP 包是否能够成功到达目标地址**：当两个设备进行互联时，其中一个设备发送给另一个设备的 IP 包如果没有到达，就会生成 ICMP 数据包发送给设备共享。
&emsp;&emsp;&emsp;② **进行网络诊断**：通过使用  ping 和 traceroute 两个终端程序来进行网络诊断。traceroute 程序用于显示两台互联网设备之间可能的路径并测量数据包在 IP 网络上的时延。ping 程序是 traceroute 的简化版本，ping 可以显示两台设备之间的延迟情况，并准确报告数据包到达目的地并返回后所花费的时间。
![[../picture/Pasted image 20240330212153.png#pic_center|480]]

###### (1). ICMP报文格式

&emsp;&emsp;一个ICMP报文包括IP报头(至少20字节)、ICMP报头(至少8字节)和 ICMP报文 (ICMP报文的数据部分) 三部分。
![[../picture/Pasted image 20240330232953.png#pic_center|350]]
![[../picture/Pasted image 20240330233136.png#pic_center|730]]

##### 3.ARP协议 - 地址解析协议
&emsp;&emsp;ARP 协议的全称是 Address Resolution Protocol (地址解析协议)，它是一个通过**用于实现从 IP 地址到 MAC 地址的映射，即询问目标 IP 对应的 MAC 地址** 的一种协议。它以 IP 地址为线索，定位下一个应该接收数据分包的主机 MAC 地址。如果目标主机不在同一个链路上，那么会查找下一跳路由器的 MAC 地址。
![[../picture/Pasted image 20240331150448.png#pic_center|180]]

###### (1). ARP工作流程
![[../picture/Pasted image 20240331120341.png#pic_center|600]]
&emsp;&emsp;&emsp;① 主机A想要获取主机 B 的 MAC 地址，通过主机A会通过**广播**的方式向以太网上的所有主机发送一个 ARP 请求包，这个 ARP 请求包中包含了主机A想要知道的主机B的IP地址的 MAC 地址。
&emsp;&emsp;&emsp;② 主机A发送的 ARP 请求包会被同一链路上的所有主机/路由器接收并进行解析。每个主机/路由器都会检查 ARP 请求包中的信息，如果 ARP 请求包中的**目标 IP 地址**和自己的相同，就会将自己主机的 MAC 地址写入响应包返回主机A。
&emsp;&emsp;&emsp;③ 通常 ARP 会被路由器隔离，但是采用代理 ARP (ARP Proxy) 的路由器可以将 ARP 请求转发给临近的网段。使多个网段中的节点像是在同一网段内通信。

###### (2). ARP报文结构
![[../picture/Pasted image 20240331144221.png#pic_center|740]]
&emsp;&emsp;&emsp;● **硬件类型**：表示硬件地址的类型，硬件地址常见的有 MAC 物理或者以太网地址
&emsp;&emsp;&emsp;● **协议类型**：指出映射的协议地址类型，对于 IPv4 地址，这个值是 0x0800
&emsp;&emsp;&emsp;● **硬件地址长度 和 协议地址长度**：分别指出硬件地址和协议地址的字节数。对于以太网中使用IPv4的ARP请求或应答，它们的值分别是 6 和 4。
&emsp;&emsp;&emsp;● **操作码**：指ARP具体的操作类型，ARP 请求 -> Op = 1，ARP 应答 -> Op = 2，RARP 请求 ->  Op = 3，RARP 应答 -> Op = 4。

###### (3). ARP攻击

&emsp;&emsp;**ARP 是一种非常不安全的协议**，使用代理 ARP 功能假扮主机，对 ARP 请求作出应答，通过伪造 ARP 数据包来窃取合法用户的通信数据，造成影响网络传输速率和盗取用户隐私信息等严重危害。常见的 ARP 攻击如下：
&emsp;&emsp;&emsp;① **ARP 泛洪攻击**：通过向网关发送大量 ARP 报文，导致网关无法正常响应。首先发送大量的 ARP 请求报文，然后又发送大量虚假的 ARP 响应报文，从而造成网关部分的 CPU 利用率上升难以响应正常服务请求，而且网关还会被错误的 ARP 缓存表充满导致无法更新维护正常 ARP 缓存表，消耗网络带宽资源。
&emsp;&emsp;&emsp;② **ARP 欺骗主机攻击**：ARP 欺骗主机的攻击也是 ARP 众多攻击类型中很常见的一种。攻击者通过 ARP 欺骗使得局域网内被攻击主机发送给网关的流量信息实际上都发送给攻击者。主机刷新自己的 ARP 使得在自己的ARP 缓存表中对应的 MAC 为攻击者的 MAC，这样一来其他用户要通过网关发送出去的数据流就会发往主机这里，这样就会造成用户的数据外泄。
&emsp;&emsp;&emsp;③ **欺骗网关的攻击**: 欺骗网关就是把别的主机发送给网关的数据通过欺骗网关的形式使得这些数据通过网关发送给攻击者。这种攻击目标选择的不是个人主机而是局域网的网关，这样就会攻击者源源不断的获取局域网内其他用户韵数据．造成数据的泄露，同时用户电脑中病毒的概率也会提升。
&emsp;&emsp;&emsp;④ **中间人攻击**: 中间人攻击是同时欺骗局域网内的主机和网关，局域网中用户的数据和网关的数据会发给同一个攻击者，这样，用户与网关的数据就会泄露。
&emsp;&emsp;&emsp;⑤ **IP地址冲突攻击**: 通过对局域网中的物理主机进行扫描，扫描出局域网中的物理主机的 MAC 地址，然后根据物理主机的 MAC 进行攻击，导致局域网内的主机产生 IP 地址冲突，影响用户的网络正常使用。

##### 4.网络层其他协议
###### (1). 虚拟专用网VPN
###### (2). 网络地址转换NAT

#### 1.2.2 网络层硬件设备
&emsp;&emsp; 路由器是网络层重要的设备，用于在不同网络之间进行数据包的转发和路由选择。一个典型的路由器通常由以下几个组成部分构成：
&emsp;&emsp;&emsp;●**中央处理单元**（Central Processing Unit，CPU）：路由器的CPU是控制和管理路由器操作的核心部件。它执行路由选择算法、处理路由表、管理接口和路由协议等任务。CPU的处理能力和性能对路由器的整体性能起着重要作用。
&emsp;&emsp;&emsp;● **接口卡**（Interface Cards）：接口卡是路由器上的插槽或模块，用于连接不同类型的网络接口。每个接口卡通常对应一个物理接口，例如以太网口、串口、光纤接口等。接口卡负责物理层和数据链路层的处理，将数据包从接口发送或接收。
&emsp;&emsp;&emsp;● **路由引擎**（Routing Engine）：路由引擎是路由器的重要组成部分，负责执行路由选择算法和管理路由表。它包括控制平面和转发平面。控制平面负责处理路由协议、学习和更新路由表，而转发平面负责实际的数据包转发和路由查找。
&emsp;&emsp;&emsp;● **存储器**（Memory）：路由器的存储器用于存储操作系统、配置文件、路由表、缓存等信息。存储器包括随机访问存储器（Random Access Memory，RAM）和只读存储器（Read-Only Memory，ROM）等。RAM用于临时存储数据和路由表，而ROM包含路由器的固件和引导程序。
&emsp;&emsp;&emsp;● **路由操作系统**（Routing Operating System）：路由器运行特定的操作系统软件，用于管理和控制路由器的各个组件。路由操作系统提供路由协议支持、管理界面、故障检测和恢复等功能。

---
### 1.3 运输层
&emsp;&emsp;运输层是计算机网络中的一个重要层级，位于网络层和应用层之间。它负责为应用程序提供端到端的可靠数据传输服务。运输层通过使用不同的协议，如 UDP - 用户数据报协议 和 TCP - 传输控制协议。
&emsp;&emsp;&emsp;● UDP 提供了简单的无连接传输服务，适用于实时性要求高、可容忍数据丢失的应用场景。
&emsp;&emsp;&emsp;● TCP 提供了可靠的面向连接传输服务，适用于对数据可靠性和有序性要求较高的应用，如文件传输、网页浏览等。

&emsp;&emsp; 传输层的主要功能包括以下几个方面：
&emsp;&emsp;&emsp; ① **连接建立与释放**：传输层协议可以通过建立连接来确保数据的可靠传输。连接建立阶段涉及握手过程，用于协商通信参数和建立通信双方之间的逻辑连接。连接释放阶段用于关闭连接并释放相关资源。
&emsp;&emsp;&emsp; ② **可靠数据传输**：传输层通过各种机制确保数据的可靠传输。例如，在TCP中，通过序列号、确认应答、超时重传、滑动窗口等机制，实现了可靠的数据传输，确保数据的正确性和有序性。
&emsp;&emsp;&emsp; ③ **段的分割与重组**：传输层将应用层的数据分割成适当的大小，并在接收端重新组装这些分段以还原原始数据。这样可以适应不同网络环境下的数据传输需求，提高传输效率和可靠性。
&emsp;&emsp;&emsp; ④ **流量控制**：传输层通过流量控制机制，调节发送方发送速率，以适应接收方的处理能力，从而避免数据的积压和丢失，保持网络的平衡和稳定。
&emsp;&emsp;&emsp; ⑤ **拥塞控制**：传输层通过拥塞控制机制，根据网络的拥塞程度来调整发送方的发送速率，以避免网络拥塞。拥塞控制可通过动态调整窗口大小、慢启动和拥塞避免算法等方式实现。

#### 1.3.1 运输层协议 
##### 1.用户数据报协议 - UDP协议
&emsp;&emsp; 用户数据报协议 (User Datagram Protocol,UDP) 提供了一种简单的、无连接的数据传输服务。UDP协议有以下几个特点：
&emsp;&emsp;&emsp; ● <font color=red>**无连接性**</font>：UDP 在通信之前不需要建立连接。发送方将数据打包成数据报并直接发送给接收方，不需要在发送和接收之间进行握手和维护连接。
&emsp;&emsp;&emsp; ●<font color=red> **不可靠性**</font>：UDP 不保证数据传输的可靠性和顺序性。数据报在传输过程中可能会丢失、重复、乱序，也不提供确认和重传机制。因此UDP在实时应用场景中更为合适，如音频和视频传输、实时游戏等。如果应用程序需要可靠的数据传输和错误处理，需要在应用层自行实现相关机制，如应答确认、重传、丢包检测等。
&emsp;&emsp;&emsp; ● **广播和多播**：UDP支持广播和多播通信，可以将数据报发送给多个接收方，方便实现群发和多点通信。
&emsp;&emsp;&emsp; ● **低开销**：由于UDP不具备连接状态的维护和复杂的控制机制，它的开销比TCP低，传输延迟较小。因此UDP 也常用于域名系统 (Domain Name System，DNS) 中进行域名解析，将域名映射到IP地址。
&emsp;&emsp;&emsp; ●  **面向数据报**：<font color=green>UDP以数据报为单位进行传输</font>，每个UDP数据报都具有独立性，接收方可以按照自己的顺序和方式处理数据报。

###### (1). UDP协议报文格式
![[../picture/Pasted image 20240410230736.png#pic_center|380]]
&emsp;&emsp;&emsp; ● **源端口** (2 字节):发送方端口号
&emsp;&emsp;&emsp; ● **目的端口** (2 字节)：接收方端口号
&emsp;&emsp;&emsp; ● **报文长度** (2 字节)：UDP 用户数据报的总长度，以字节为单位
&emsp;&emsp;&emsp; ● **校验和** (2 字节)：用于校验 UDP 数据报的数字段和包含 UDP 数据报首部的“伪首部”。检测 UDP 用户数据报在传输中是否有错，有错就丢弃。
&emsp;&emsp;&emsp; ● **伪首部**， 又称为伪包头 (Pseudo Header) ：是指在 UDP 的数据报格式中，在数据报首部前面增加源 IP 地址、目的 IP 地址、IP 分组的协议字段、UDP 数据报的伪首部总长度等共12字节，所构成的扩展首部结构。此伪首部是一个临时的结构，并不是UDP真正的首部，它既不向上也不向下传递，仅仅只是为了保证可以校验套接字的正确性。

##### 2. 传输控制协议 - TCP协议
&emsp;&emsp; 传输控制协议 (Transmission Control Protocol,TCP) 通过提供可靠性、拥塞控制和流量控制等功能，为应用程序提供了稳定、可靠的数据传输服务。TCP协议有以下几个特点：
&emsp;&emsp;&emsp; ● <font color=red>**可靠性**</font>：TCP提供可靠的数据传输，确保数据按顺序、完整地到达目的地。通过确认和重传机制，TCP能够检测并纠正数据在传输过程中的丢失、重复或乱序。
&emsp;&emsp;&emsp; ● **面向连接**：TCP是一种面向连接的协议，发送方和接收方在进行数据传输之前需要建立连接。<font color=red>连接的建立和释放通过三次握手和四次挥手的过程来完成。</font>
&emsp;&emsp;&emsp; ● **流量控制**：TCP使用流量控制机制来平衡发送方和接收方之间的数据传输速率。接收方可以通过通告窗口来告知发送方它还有多少可接收的缓冲区空间，从而控制发送方的发送速率，防止接收方的缓冲区溢出。
&emsp;&emsp;&emsp; ● **拥塞控制**：TCP具有拥塞控制机制，以防止网络拥塞和资源浪费。通过使用拥塞窗口和慢启动等算法，TCP可以根据网络的拥塞情况动态调整发送数据的速率，确保网络的稳定性和公平性。
1面向字节流：TCP以字节流的方式传输数据，将应用程序发送的数据分割成较小的数据块（报文段），并通过序号进行标记。接收方根据序号和确认机制将数据块重新组装成完整的数据，提供给应用程序。
###### (1). TCP协议报文格式
![[../picture/Pasted image 20240414181824.png#pic_center|650]]
&emsp;&emsp;&emsp; ● **源端口**：源端口和IP地址的作用是标识报文的返回地址。
&emsp;&emsp;&emsp; ● **目的端口**：端口指明接收方的应用程序接口。
&emsp;&emsp;&emsp; ● **序号 ISN**：序号和确认号是TCP可靠传输的关键部分。**序号**是本报文段发送的数据组的第一个字节的序号。在TCP传送的数据流中，每一个字节一个序号。序号确保了TCP传输的有序性。
&emsp;&emsp;&emsp; ● **确认号 ACK**：指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。
&emsp;&emsp;&emsp; ● **数据偏移／首部长度**：由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，即 `15 * 4 = 60` (可变部分的最大长度为32位，共4个字节)，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
&emsp;&emsp;&emsp; ●**控制位**：每一个标志位表示一个控制功能，共6个控制位。
&emsp;&emsp;&emsp; &emsp; ● URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。
&emsp;&emsp;&emsp; &emsp; ● ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
&emsp;&emsp;&emsp; &emsp; ● PSH：push标志，为1表示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
&emsp;&emsp;&emsp; &emsp; ● RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
&emsp;&emsp;&emsp; &emsp; ● SYN：同步序号，用于建立连接过程。
&emsp;&emsp;&emsp; &emsp; ● FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了。
&emsp;&emsp;&emsp; ● **滑动窗口大小**：用来告知发送端/接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。
&emsp;&emsp;&emsp; ● **校验和**：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。
&emsp;&emsp;&emsp; ● **紧急指针**：只有当 URG 标志置 1 时紧急指针有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。
&emsp;&emsp;&emsp; ● **选项和填充**：最常见的可选字段是最长报文大小，又称为MSS (Maximum Segment Size)，每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。
><font color=SlateBlue>  <u>**Q1. 数据在IP层会分片，为什么TCP还需要MSS ？**</u></font>
>&emsp;&emsp;&emsp; 一个数据包想从发送端传输到接收端，但数据包的量有大有小，而网络的带宽是固定的，数据包不能大于网络层设定的 MTU 大小。当数据包过大时就需要切分成小块。这个行为在**传输层和网络层**都有可能发生。在传输层 (TCP协议) 里，叫**分段**，这个最大长度是 MSS。在网络层 (IP层)，叫**分片**，这个最大长度是 MTU。
>&emsp;&emsp;&emsp; 由于本身IP层就会做分片这件事情。**就算TCP不分段**，到了IP层，数据包也会被分片，数据也能**正常传输**。假设有一份较大数据，且在TCP层不分段，如果这份数据在发送的过程中出现**丢包**现象，TCP会发生重传，那么重传的就是这一大份数据。
>&emsp;&emsp;&emsp;如果TCP把这份数据，分段为N个小于等于MSS长度的数据包，且MSS < MTU，到了IP层后加上IP头和TCP头，还是小于MTU，那么IP层也不会再进行分包。此时在传输路上发生了丢包，那么TCP重传的时候也只是重传那一小部分的MSS段。效率会比TCP不分段时更高。
>![[../picture/Pasted image 20240415222834.png#pic_center|350]]
>
><font color=SlateBlue>  <u>**Q2. 如果要做到在整个传输链路中IP层不分片，应该如何做 ？**</u></font>
>

###### (2). TCP的连接管理
&emsp;&emsp;TCP运输连接有三个阶段：**连接建立** (三次握手)，**数据传送**，**连接释放** (四次挥手)。
&emsp;&emsp;&emsp; ● **三次握手**：为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。
&emsp;&emsp;&emsp; ● **四次挥手**：即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。

**▨ TCP 的连接建立**

&emsp;&emsp; 在TCP协议中，在通信双方进行数据传输之前，它们需要通过三次握手来确认双方的通信能力，并同步彼此的初始序列号。这一过程确保了连接的稳定性和数据传输的准确性。三次握手主要有以下四个作用和目的：
&emsp;&emsp;&emsp; <font color=red>① **TCP连接的建立**</font>：TCP协议是基于连接的协议，因此在双方开始传输数据之前，必须先建立连接。三次握手是连接建立过程中的关键步骤，它为后续的数据传输奠定基础。
&emsp;&emsp;&emsp; <font color=red>② **双方的通信能力确认**</font>：通过三次握手，客户端和服务器可以确认彼此具有发送和接收数据的能力。在握手过程中，双方分别发送和接收特定格式的TCP报文，验证彼此的通信能力。确保连接建立后，数据能够正确地在双方之间传输。
&emsp;&emsp;&emsp;<font color=red>③ **初始序列号同步**</font>：TCP协议中，每个数据包都有一个序列号。在三次握手过程中，客户端和服务器会交换并确认彼此的初始序列号。在后续的数据传输过程中，双方可以根据序列号来跟踪和确认数据包的发送和接收情况，从而确保数据的完整性和有序性。
&emsp;&emsp;&emsp; <font color=red>④ **防止已失效的连接请求报文突然传到服务端，产生错误**</font>：TCP三次握手可以防止已失效的报文段在网络中延迟传输，以致于在连接已经建立后又传到服务端。如果没有三次握手，这些失效的报文段可能导致服务端错误地重新建立连接，从而影响通信质量。

![[../picture/Pasted image 20240421102803.png]]

-  **1、第一次握手：客户端发送SYN报文**  [`SYN=1,seq=x`]
	- **客户端创建套接字:**  
            &emsp;&emsp;在TCP连接的建立过程中，客户端首先需要创建一个套接字 (socket)，它是用于处理TCP连接的一个数据结构。套接字包含了连接所需的所有信息，如本地和远程地址、端口号等。  
	- **设置SYN标志位和初始序列号:**  
          &emsp;&emsp;客户端准备好建立连接后，会创建一个TCP报文段。在这个报文段中，客户端会设置 SYN 标志位，表示请求建立连接。同时，客户端会生成一个随机的初始序列号 ISN，并将其放入报文段的序列号字段 (seq = x)。  
	- **客户端进入SYN-SENT状态:**  
          &emsp;&emsp;客户端发送SYN报文段后，会进入SYN-SENT状态。在此状态下，客户端等待服务器的响应。如果在一定时间内没有收到服务器的响应，客户端可能会重发SYN报文段，并重新计时等待响应。

- **2、第二次握手：服务器回应SYN-ACK报文** [`SYN=1,ACK=1,seq=y,ack=x+1`]
	- **服务器接收到SYN报文:**
	  &emsp;&emsp;&emsp;当服务器收到客户端发送的SYN报文后，会解析其中的信息，如客户端的初始序列号。服务器根据这些信息，准备好与客户端建立连接。
	- **服务器创建套接字，设置SYN和ACK标志位:**
	  &emsp;&emsp;&emsp;服务器同样需要创建一个套接字，用于处理与客户端的TCP连接。在准备好回应客户端的报文时，服务器会设置SYN标志位，并生成自己的初始序列号。同时，服务器会设置 ACK 标志位，并将客户端的初始序列号加1作为确认号，以告知客户端已收到其连接请求。
	- **服务器确认客户端的初始序列号，并提供自己的初始序列号:**
	  &emsp;&emsp;&emsp;通过回应的SYN-ACK报文，服务器告知客户端已收到其初始序列号，并提供了自己的初始序列号。这样，双方就可以根据彼此的序列号在后续的通信过程中对数据包进行追踪和确认。
- **3、第三次握手：客户端回应ACK报文** [`ACK=1,seq=x+1,ack=y+1`]
	- **客户端接收到SYN-ACK报文:**
	  &emsp;&emsp;&emsp;客户端接收到SYN-ACK报文：当客户端收到服务器发来的SYN-ACK报文后，会解析其中的信息，如服务器的初始序列号和确认号。客户端通过这些信息进一步确认服务器已准备好建立连接，并可以进行通信。
	- **客户端确认服务器的初始序列号:**
	  &emsp;&emsp;&emsp;客户端会检查服务器发送的确认号 (acknowledgment number) 是否与自己的初始序列号加1相等。如果确认号正确，说明服务器已收到客户端的连接请求，并且双方的初始序列号已经同步。
	- **客户端发送ACK报文并更新序列号:**
	  &emsp;&emsp;&emsp;客户端会发送一个ACK报文给服务器，以确认已收到服务器的SYN-ACK报文。在这个报文中，客户端会设置ACK标志位，并将服务器的初始序列号加1作为确认号。同时，客户端会更新自己的序列号。
	- **客户端和服务器进入ESTABLISHED状态:**
	  &emsp;&emsp;&emsp;在客户端发送ACK报文后，客户端和服务器都会进入ESTABLISHED状态，这意味着TCP连接已成功建立。从这一刻开始，双方可以开始进行数据传输。

><font color=SlateBlue>  <u>**Q1. TCP 建立连接过程中会出现哪些出错的情形 ？**</u></font>
>
>&emsp;&emsp;● 第一次握手时出错： 
> &emsp;&emsp;&emsp; 如果客户端在发送SYN报文时出错，如报文丢失或损坏，服务器将无法收到连接请求。在这种情况下，服务器不会回应客户端，而客户端会在一定时间内重发SYN报文。如果重发次数超过预设阈值，客户端将放弃连接请求，导致连接建立失败。
> 
> &emsp;&emsp;● 第二次握手时出错：
> &emsp;&emsp;&emsp; 如果服务器在回应客户端的SYN报文时出错，如SYN-ACK报文丢失或损坏，客户端将无法收到服务器的回应。在这种情况下，客户端会继续等待一段时间，然后重发SYN报文。如果重发次数超过预设阈值，客户端将放弃连接请求，导致连接建立失败。
> 
> &emsp;&emsp;● 第三次握手时出错 - SYN超时：
> &emsp;&emsp;&emsp; 如果客户端在发送ACK报文时出错，如报文丢失或损坏，服务器将无法收到客户端的确认。在这种情况下，服务器会认为客户端尚未收到SYN-ACK报文，可能会在一定时间内重发SYN-ACK报文。如果客户端收到重发的SYN-ACK报文，将再次发送ACK报文。但如果重发次数超过预设阈值，服务器可能会放弃连接请求，导致连接建立失败。
> 
> <font color=SlateBlue>  <u>**Q2. 什么是SYN攻击，如何避免 ? **</u></font>
> &emsp;&emsp;&emsp; 根据TCP的连接过程，如果在第三次握手时出错 (即客户端发起连接请求后马上断开，会导致第三次握手失败)。此时服务器会认为客户端尚未收到SYN-ACK报文，可能会在超时时间内重发SYN-ACK报文。Linux 下默认会进行 5 次重发 SYN-ACK 包，重试的间隔时间从 1s 开始，5 次的重试时间间隔为 1s,2s, 4s, 8s,16s，总共间隔31s，第 5 次重试要在第32s开始，重试后的间隔为32s。所以，总共需要 1s + 2s +4s+ 8s+ 16s + 32s =63s，TCP 才会把断开这个连接。由于，SYN 超时需要 63 秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内 (63s内) 伪造不同的IP地址的SYN报文 (俗称 SYN flood 攻击)，服务端每接收一个报文就会进入 SYN_RCVD 状态，并加入SYN接收队列，但是返回的 ACK+SYN 报文无法得到伪造IP主机的ACK应答，从而导致服务端SYN接收队列占满，服务器不能正常接收用户服务。
> ![[../picture/Pasted image 20240424222227.png#pic_center|330]]
> 
><font color=SlateBlue>  <u>**Q3. 为什么初始序列号ISN不同，能否将ISN固定，如何产生的 ？**</u></font>
>&emsp;&emsp;&emsp; 网络中的报文会延迟、会复制重发、也有可能丢失。为了避免报文的延迟，重发互相影响，客户端和服务端的初始序列号是随机且不同的。同时，如果固定 ISN 很容易让攻击者猜测到TCP连接的 ISN。在RFC793 中，建议 ISN 和一个假的时钟绑在一起，这个时钟会在每 4 微秒对 ISN 做加一操作，直到超过 $2^{32}$，又从 0 开始，这需要 4 小时才会产生 ISN 的回绕问题，保证了每个新连接的 ISN 不会和旧的连接的 ISN 产生冲突。因此，ISN 是基于时钟产生的，ISN=计时器+Hash算法。

**▨ TCP 连接断开**

&emsp;&emsp;TCP连接的释放采用四次挥手方式 (优雅的关闭)，确保在关闭连接时，双方在结束连接前都能有充分的时间确认对方已收到所有数据，避免了在连接突然中断时可能出现的数据丢失问题，从而确保了数据传输的可靠性。四次挥手主要有以下四个作用和目的：
&emsp;&emsp;&emsp; <font color=red> ① **有序关闭连接**</font>：四次挥手过程确保了连接能够有序地关闭。双方通过交换FIN和ACK报文，表明自己已完成数据传输并希望关闭连接。这种有序的方式避免了由于意外断开连接而导致的数据丢失或损坏。
&emsp;&emsp;&emsp; <font color=red> ② **连接资源释放**</font>：在TCP连接结束时，双方需要释放与连接相关的资源，例如套接字、缓冲区、端口号等。四次挥手确保了双方在关闭连接时，能够正确地释放这些资源，避免资源浪费和潜在的问题。
&emsp;&emsp;&emsp; <font color=red> ③ **双方通信的终止**</font>：TCP协议支持双向通信，因此在结束连接时，需要确保双方都同意终止。四次挥手过程让双方都有机会发送FIN报文和确认接收到对方的FIN报文，确保连接能够在双方都同意的情况下终止。
&emsp;&emsp;&emsp; <font color=red> ④ **防止半关闭 (Half-Close) 状态**</font>：在四次挥手过程中，双方通过发送FIN报文表明自己已完成数据传输。这避免了半关闭状态，即一方认为连接已关闭，而另一方仍在发送数据。半关闭状态可能导致数据丢失或其他错误。
&emsp;&emsp;&emsp; <font color=red> ⑤ **避免连接重建时的资源冲突**</font>：当一个连接被关闭后，相应的套接字、端口号等资源可能会被重新分配给新的连接。四次挥手确保了连接能够正确地关闭，避免了在连接重建时可能出现的资源冲突。

![[../picture/Pasted image 20240426230909.png#pic_center|530]]

-  **1、第一次挥手：客户端发送FIN报文**  [`FIN=1,seq=u`]
  &emsp;&emsp;&emsp;在连接终止的过程中，当客户端决定关闭连接时，它会向服务端发送一个 FIN 报文，这个报文表示客户端不再向服务端发送数据，即关闭客户端到服务端的数据传输通道。
-  **2、第二次挥手：服务端确认并发送ACK报文**  [`ACK=1,seq=v,ack=u+1`]
  &emsp;&emsp;&emsp;服务器端收到 FIN 报文后，会发送一个ACK报文来确认收到 FIN 报文。此时TCP连接处于半关闭 (Half-closed) 状态。在这一阶段，**服务端可以继续向客户端发送数据**，直到最后一个数据包发送完毕，但客户端不能向服务端发送数据。
  
 - **3、第三次挥手：等服务端发送完数据，服务端再次发送FIN报文**  [`FIN=1,ACK=1,seq=w,ack=u+1`]
   &emsp;&emsp;&emsp;当服务端所有数据都已发送完毕，服务端会再发送一个FIN报文，表示服务器也不再向客户端发送数据，服务器准备关闭与客户端的数据传送通道。

 - **4、第四次挥手：客户端确认并发送ACK报文**  [`ACK=1,seq=u+1,ack=w+1`]
   &emsp;&emsp;&emsp;当客户端收到服务端再次发送的FIN报文后，它会发送一个ACK报文来确认收到FIN报文。当服务端收到二次确认的ACK报文后，TCP连接被成功终止，双方都关闭了数据传输通道。

><font color=SlateBlue>  <u>**Q1. 在客户端主动发起断开时，为什么在TCP连接释放时客户端A存在 `TIME-WAIT` 状态 ？**</u></font>
>  &emsp;&emsp;TCP主动关闭连接的那一方会最后进入`TIME-WAIT`，因此，如果客户端主动关闭，则客户端就会出现TIME-WAIT状态，如果服务端主动关闭，则服务端就会出现 `TIME-WAIT`。
>  &emsp;&emsp;`TIME-WAIT` 状态主要有以下两个目的：
>  &emsp;&emsp;  ① **防止连接关闭时四次挥手中的最后一次ACK丢失**：由于TCP的协议标准要求，不对 ACK 报文进行 ACK 响应，因此被动关闭方无法对主动关闭方的 ACK 报文进行回应 (客户B不会响应客户A的ACK报文)。如果没有 `TIME-WATI` 状态，当主动发送方发送 ACK 报文后进入 CLOSED 状态，由于网络问题，ACK 报文丢失，此时就会造成主动发送方关闭，而被动发送方长时间的处于 LAST_ACK 状态而无法正常关闭 (只能等到达到FIN的最大重传次数后关闭)。
>  &emsp;&emsp;如果此时新建一个连接，源随机端口如果被复用，在新连接发送SYN包后，由于被动关闭方仍认为这条连接还在等待ACK，但是却收到了SYN，则被动方会回复RST，造成主动创建连接的一方，由于收到了RST，则连接无法成功。因此，<font color=green>主动关闭方需要进入 `TIME-WAIT`状态，保证 ACK 报文被被动关闭方接受 (被动关闭方未收到 ACK 报文，会重发FIN 确认请求)。</font>
>  &emsp;&emsp;  ② **防止新连接收到旧链接的TCP报文**：由于TCP使用四元组区分一个连接 (源端口、目的端口、源IP、目的IP)，当新、旧连接的IP与端口号完全一致，则内核协议栈无法区分这两条连接。如果在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，在"新连接"建立连接过程中，可能受到仍然在网络中的"前一个连接"的因网络问题导致重发的延迟报文的影响。
>  ![[../picture/Pasted image 20240427095633.png#pic_center|380]]
>  
>  &emsp;&emsp; 因为报文在链路中的最大生存时间为MSL，超过这个时长后报文就会被丢弃，同时为了防止最后一次 ACK 报文丢失，将TIME_WAIT的时长设置为 2MSL。即 <font color=red>**`TIME_WAIT` = 最后一次ACK传输到服务器的时间 (清空网络中上一次连接的数据包) + 服务器重传FIN 的时间 (防止连接丢失)**</font>，即为 2MSL。
>
><font color=SlateBlue>  <u>**Q2. 连接中`TIME-WAIT` 状态过多会有什么问题？**</u></font>
>   &emsp;&emsp; 当连接处于 `TIME_WAIT` 状态时仍会占用系统资源 (fd、端口、内存)，过多的 `TIME_WAIT` 状态的连接会对系统的并发量造成影响。
>   &emsp;&emsp; **① 对客户端的影响**：当客户端主动关系连接，出现大量的 `TIME_WAIT` 时，`TIME_WAIT` 状态的连接就占用了一个本地端口。这样在`TIME_WAIT` 状态结束之前，本地最多就能承受6万个 (最大端口为65535) `TIME_WAIT` 状态的连接，就无端口可用了，会限制了客户端的并发率，同时，大量的TIME_WAIT连接同样会消耗客户端的内存。
>   &emsp;&emsp; **② 对服务端的影响**：由于服务器一般只需要监听一个固定的端口，所以服务器所能支持的最大并发出数的上限取决于系统套接字描述符fd的大小，以及服务器的内存大小。当服务器主动关闭连接，产生 `TIME_WAIT` ，每一个连接需要占用一定大小的内存资源，当 `TIME_WAIT` 状态的连接过多时，会导致消耗的内存增加。
>   
><font color=SlateBlue>  <u>**Q3. 如何解决大量连接处于TIME-WAIT问题 ？**</u></font>
>&emsp;&emsp; 

###### (3). TCP 滑动窗口与流量控制
&emsp;&emsp;  **滑动窗口**是TCP协议中的重要机制，用于**控制、管理发送方和接收方之间的数据传输**。是TCP实现流量控制和拥塞控制的基础。
&emsp;&emsp;&emsp; TCP 由于存在确认应答机制，在一方发出一条消息以后，另一方要发送 ACK 响应表明自己收到消息，每次收到 ACK 才发出下一条消息，这种一发一收的效率太低。但是如果客户端不急着接收 ACK，可以利用等待 ACK 的空挡直接发送下一批数据，这样就可以在短时间内发送多批数据。这就是滑动窗口的基本思想。

![[../picture/Pasted image 20240506234642.png#pic_center|230]]

&emsp;&emsp;滑动窗口它是操作系统开辟的一个缓存空间，窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。滑动窗口机制允许发送方和接收方之间实现**流量控制和可靠性传输**。**发送方可以持续发送数据而不需要等待每个数据段的 ACK 确认**，从而提高传输**效率**。接收方可以根据**自身的处理能力和缓冲区空间**调整窗口大小，从而控制发送方窗口大小。<font color=red>滑动窗口就结果而言，看起来像是在滑动，其本质是**根据是否收到ACK以及对方接收缓冲区的大小来移动左右边界**。</font>

![[../picture/Pasted image 20240427213554.png#pic_center|400]]

&emsp;&emsp;  在TCP中，滑动窗口分为两种: 发送窗口和接收窗口。窗口由两个参数定义：窗口的起始字节和窗口的大小。
&emsp;&emsp;&emsp; ● TCP接收窗口的起始默认值为4096字节，TCP发送窗口的默认值为16384字节。
&emsp;&emsp;&emsp; ● 滑动窗口的大小是通过 TCP 报文中的 Windows 字段来告诉发送方自己还有多少缓冲区可以接收数据。

**▨ 发送方滑动窗口**

&emsp;&emsp;发送端的滑动窗口包含四大部分：① 已发送且已收到 ACK 确认；②  已发送但未收到 ACK 确认；③ 未发送但可以发送；④ 未发送也不可以发送。

![[../picture/Pasted image 20240429230355.png#pic_center|680]]

**▨ 接收方滑动窗口**

&emsp;&emsp;  接收方的滑动窗口包含三大部分：① 已成功接收并确认；② 未收到数据但可以接收；③ 未收到数据并不可以接收的数据。
![[../picture/Pasted image 20240429230943.png#pic_center|500]]

**▨ 流量控制过程**

&emsp;&emsp; ① **初始化窗口大小**：在建立TCP连接时，双方协商并初始化流量控制的参数 (TCP三次握手时, 服务端会跟据自身处理数据能力和接收缓冲区大小, 告诉客户端自己的接收窗口大小，客户端据此设置自己的初始化发送窗口大小)。 其中包括窗口大小 (通常是以字节为单位的接收缓冲区大小) 和初始的拥塞窗口大小。

&emsp;&emsp; ② **接收窗口通告**：
&emsp; &emsp; &emsp;每次发送数据，服务端通过TCP报文段中的 **win"窗口大小"字段**，通知客户端其当前可接收的字节数。这个窗口大小可以动态调整以反映服务端接收缓冲区的可用空间。

&emsp;&emsp; ③ **客户端发送数据，确认等待**：
&emsp; &emsp; &emsp;客户端维护一个发送窗口，它表示客户端可以发送的字节数。客户端根据服务端通告的窗口大小，不用等待服务端一个一个的返回ACK响应，先把发送窗口内的数据都发送给服务端，但不会超出发送窗口限制，然后收到一个ACK移动一次，直到丢包一直等待收到丢包数据段ACK。

&emsp;&emsp; ④ **服务端接收数据，动态调整窗口大小，并发送ACK**：
&emsp; &emsp; &emsp;  ● 服务端接收到数据报段后，会返回一个ACK确认报文给接收方，ACK就是服务端期待收到的下一个数据报的序列号，客户端等待服务端对已发送数据的确认，随后看情况移动窗口。
&emsp; &emsp; &emsp;  ● 服务端同时会根据自身的可用缓冲区空间和处理能力，动态调整**窗口大小**，并将新的窗口大小放在首部 win 字段中随ACK应答通告给客户端，客户端根据 win 大小进行数据发送控制。

&emsp;&emsp;⑤ **客户端窗口滑动**
&emsp;&emsp;&emsp;客户端根据服务端的ACK报文和通告窗口大小，将窗口在发送缓冲区中**向前滑动**。ACK报文有以下几种情况:
&emsp; &emsp; &emsp;  ● 如果报文中win=0，客户端停止发送，并开启一个定时任务，定时询问接受方，直到 win 大于 0，才继续开始发送数据。
&emsp; &emsp; &emsp;  ● 如果接收的ACK值等于服务端接收窗口最左侧的报文段序号, 说明该报文段服务端还没收到，则客户端的发送窗口停止滑动。
&emsp; &emsp; &emsp;  ● 如果服务端发送请求某个报文段的确认ACK超过三次，或有报文段超时重传，客户端会假设网络发生拥塞，并采取拥塞控制机制。


><font color=SlateBlue>  <u>**Q1. 接收窗口和发送窗口的大小是相等的吗？**</u></font>
>&emsp;&emsp;&emsp; 接收窗口和发送窗口的大小并不是完全相等，接收窗口的大小是**约等于**发送窗口的大小的。因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。
>
><font color=SlateBlue>  <u>**Q2. 当滑动窗口大小为0时，何时才能继续发送数据？**</u></font>
>&emsp;&emsp;&emsp;如果接收方的数据处理速度较慢，导致接收缓冲区里的数据没有被取走，发送端的滑动窗口只有左边界在移动，发送端滑动窗口的大小很快就会变成0，从而导致发送方无法发送任何数据。为了应对这种情况，TCP有两种策略：
>&emsp;&emsp;&emsp; ① 发送方定期 (每 5 到 60 秒) 发送不携带数据的报文，这个数据可能不会被接受，但还是发送方会尝试发送，因为每个报文都会触发接收方包含当前滑动窗口的响应，直到接收方最终返回了非零值的滑动窗口。这些不携带数据的报文的消息被称为零窗口探测 (Zero Window Probes) 。
>&emsp;&emsp;&emsp; ② 接收方缓冲区一旦更新为非零值 (接收方从缓冲区将数据取走)，立马通知发送方。接收端会主动发送一个窗口更新的通知报文，该报文不携带任何数据，只是在报文首部设置了16位窗口大小。
>
><font color=SlateBlue>  <u>**Q3. 什么是糊涂窗口综合征，如何解决？**</u></font>
>&emsp;&emsp;&emsp;当接收端应用进程处理接收缓冲区数据很慢时，会导致客户端的滑动窗口很小，就会使应用进程间传送的报文段很小，而TCP 报文首部就占 20 字节了，如果每次发送两三个字节，为了传输几个有效的字节，还得附加上 20 字节的数据，就会导致很大的资源性能浪费。因此要解决糊涂综合征就要防止发送方发送小数据。从发送方和接收方来看分别有以下方法：
>&emsp;&emsp;&emsp;● **发送方**：
>&emsp; &emsp; &emsp;  ① 只要窗口大小 < 某个值 (内核缓冲区大小的一半) 的时候，就直接讲窗口大小置为0，防止发送小数据。-等到窗口大小 >= 某个值的时候，才打开窗口通告发送方，告知其可以发送数据了。
>&emsp; &emsp; &emsp;  ② 延迟确认应答：接收方接收到数据后不会立刻发送ACK确认报文，只有从缓冲区中清理的数据就变多之后，窗口变大了，再向发送方发送ACK确认报文。
>&emsp;&emsp;&emsp;● **接收方**：
>&emsp; &emsp; &emsp;  接收方通常采用 **Nagle 算法**，即若发送方还有数据待发送，但数据比较小，就可以进行延迟发送，直到可以发送的数据 >= 某个值 (内核缓冲区大小的一半)。


###### (4). TCP 拥塞控制
&emsp;&emsp;数据在网络中传输，由于网络的不可靠因素，可能会产生数据丢包问题。产生丢包的主要原因有：
&emsp;&emsp;&emsp; ① 服务端处理数据的速度有限，而发送方发送数据速率太快，服务端处理不过来，导致服务端缓冲区装不下溢出丢失；
&emsp;&emsp;&emsp; ② 网络情况差，报文段因为网络拥塞或者数据量过大超过网络带宽，导致数据包迟迟不到，超时丢包。
&emsp;&emsp;&emsp; ③ 不可控因素。物理传输过程中受损、丢失，或者路由错误导致的数据包丢失。

&emsp;&emsp;TCP的拥塞控制就是解决第二种丢包问题。当数据传输没有考虑网络带宽和延迟，而直接将数据全发出去，数据包在比较差的网络环境中会产生丢包或者在网络带宽较低的情况下延迟到达。这时就会触发客户端的超时重传，导致⽹络的负担更重，造成更⼤的延迟以及更多的丢包，产生恶性循环。
&emsp;&emsp;&emsp;拥塞控制的目的就是**保证网络拥塞时网络的稳定性、公平性**。拥塞控制机制会根据网络的拥塞程度，自适应地调整发送数据的速率，尽量避免网络拥塞发生，并在发生网络拥塞时进行快速调整和恢复。客户端会维护一个**拥塞窗口 cwnd (Congestion Window)** 的变量，调节所要发送数据的量。

**▨ 拥塞控制的过程**

&emsp;&emsp;拥塞控制主要有以下四个部分组成：**慢启动、拥塞避免、快速重传、快速恢复**。
&emsp;&emsp;&emsp;  ● <font color=red>慢启动 + 拥塞避免：主要解决出现网络拥塞而导致报文丢失的问题。</font>
&emsp;&emsp;&emsp;  ● <font color=red>拥塞避免 + 快重传 + 快恢复：主要解决非网络拥塞产生的报文丢失的问题。</font>

&emsp;&emsp;① **慢启动**
&emsp;&emsp;&emsp; 在连接刚建立时，客户端**将初始拥塞窗口设置为一个较小的值** (通常是一个报文段的大小)。每当客户端**收到一个 ACK 确认应答时，拥塞窗口就会加倍**。之后客户端会逐渐增加发送的数据量，从而实现慢慢地**探测网络的容量**。一旦出现丢包，就将拥塞窗口减半，进入拥塞避免阶段。

&emsp;&emsp;② **拥塞避免**
&emsp;&emsp;&emsp; 一旦拥塞窗口达到一个**阈值** (通常是网络的带宽和延迟的函数)，客户端将进入**拥塞避免阶段**。拥塞避免并非完全能够避免拥塞，在拥塞避免阶段，客户端每收到一个确认应答时，拥塞窗口的增长将变慢，谨慎地增加数据发送量，以防止过度拥塞网络。**无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞 (其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。**

![[../picture/Pasted image 20240510221700.png]]

&emsp;&emsp;③ **快速重传**
&emsp;&emsp;&emsp; 快重传要求服务端在收到一个失序的报文段后就立即发出重复确认 (目的是使客户端及早知道有报文段没有到达对方) 。快重传算法规定，当客户端连续收到3个重复的 ACK 确认应答时，它会推断某个报文段丢失，并立即重传该报文段，而不等待超时重传的时间。这样可以更快地恢复丢失的报文段，提高传输效率。

&emsp;&emsp;④ **快速恢复 - 与快重传配合使用**
&emsp;&emsp;&emsp; 当客户端接收到重复确认应答时，它会将拥塞窗口减半，并进入快速恢复阶段。在快速恢复阶段，发送方每收到一个确认应答时，拥塞窗口的增长将变得更慢，并且不再执行慢启动算法，而是执行拥塞避免算法。

![[../picture/Pasted image 20240510221755.png]]

---
### 1.4 应用层
&emsp;&emsp; 应用层是计算机网络协议栈中的最顶层，负责处理应用程序之间的通信和数据交换。它提供了各种协议和服务，使得不同设备和应用程序能够进行网络通信。应用层的功能包括以下几个方面：
&emsp;&emsp;&emsp; ① **协议和通信**：应用层定义了各种协议，如HTTP (超文本传输协议)、FTP (文件传输协议)、SMTP (简单邮件传输协议)等，用于不同应用程序之间的通信。这些协议规定了数据的格式、传输方式和交互规则。
&emsp;&emsp;&emsp; ② **数据表示和编码**：应用层负责将数据表示为特定格式，以便应用程序之间进行交换和解释。例如，在Web应用中，数据通常使用 HTML、JSON 或 XML 等格式进行表示和传输。
&emsp;&emsp;&emsp; ③ **安全和身份验证**：应用层提供了安全机制，以保护数据和通信的安全性。这包括加密通信、数字签名、身份验证和访问控制等。常见的安全协议和技术，如 SSL/TLS、OAuth 等就是在应用层实现的。
&emsp;&emsp;&emsp; ④ **远程访问和控制**：应用层支持远程访问和控制，使得用户可以从远程位置访问和操作其他计算机或设备上的应用程序和资源。远程桌面、SSH (安全外壳协议) 等就是在应用层实现的。

#### 1.4.1 应用层协议 
##### 1.超文本传输协议 - HTTP协议
&emsp;&emsp; 超文本传送协议 (Hypertext Transfer Protocol，HTTP）是用于在计算机网络中传输超文本 (包含文本、图像、视频等多媒体) 的应用层协议。**HTTP 基于 TCP/IP 通信协议来传递数据**，它是万维网 (WWW) 的基础，用于在Web浏览器和Web服务器之间传输网页和其他资源。HTTP的主要特点如下：
&emsp;&emsp;&emsp; ① <font color=red>**无连接的请求-响应模型**</font>：HTTP采用请求-响应模型，客户端 (通常是Web浏览器) 发送HTTP请求到服务器，服务器接收请求后处理，并返回相应的HTTP响应给客户端。请求和响应之间是独立的，每次连接只处理一个请求，服务器处理完客户的请求并收到客户的应答后就断开连接。采用这种方式可以节省传输时间。(注: HTTP1.1 版本后支持可持续连接)
&emsp;&emsp;&emsp; ② <font color=red>**无状态协议**</font>：HTTP是无状态的，即服务器不保留之前的请求和响应信息。每个HTTP请求都是独立的，服务器只处理当前请求，不记忆之前的请求历史。
&emsp;&emsp;&emsp; ③ **基于TCP**：HTTP是基于TCP的，它使用TCP提供的可靠数据传输和连接管理功能。每个HTTP请求和响应都使用一个TCP连接来传输数据。

###### (1). Http协议报文格式
&emsp;&emsp; HTTP报文，是服务器和客户端之间交换数据的方式。有两种类型的消息：**请求报文、响应报文**。HTTP 消息由采用 ASCII 编码的多行文本构成。在HTTP/1.1及早期版本中，这些消息通过连接公开地发送。在HTTP/2中，为了优化和性能方面的改进，数据消息被分到多个HTTP帧中。

**▨ 请求报文**

&emsp;&emsp;一个HTTP请求报文由请求行 (request line)、请求头 (header)、空行 (CRLF)、请求数据 (也称请求体) 4个部分组成。

![[../picture/Pasted image 20240512175115.png#pic_center|650]]
&emsp;&emsp;&emsp; ① **请求行**：由**请求方法** (Method)字段、**URL**字段和 **HTTP协议版本** (HTTP-Version)字段3个字段组成，它们用空格分隔。

![[../picture/Pasted image 20240514222928.png#pic_center|600]]

&emsp;&emsp;&emsp; ② **请求头部**：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔 (**`key:value`**)。请求头部通知服务器有关于客户端请求的信息，常见的请求头如下：

![[../picture/Pasted image 20240514223015.png#pic_center|550]]

><font color=SlateBlue>  <u>**Q1.  HTTP请求 GET 和 POST 的区别？**</u></font>
>&emsp;&emsp; ①  **传输数据的方式不同**：
>&emsp; &emsp; &emsp;  ● GET提交：GET请求的数据会附在URL之后，以 ? 分割 URL 和传输数据，多个参数用 \& 连接。
>&emsp; &emsp; &emsp;  ● POST提交：POST请求的数据放在 Request body 中。
>&emsp;&emsp; ② **传输数据的大小不同**：
>&emsp; &emsp; &emsp;  ● GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节。
>&emsp; &emsp; &emsp;  ● POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对 POST 提交数据大小进行限制。
>&emsp;&emsp; ③ **POST比GET安全性更高**
>&emsp; &emsp; &emsp; POST 的安全性要比 GET 的安全性高是因为 GET 传递的参数直接暴露在URL上，所以不能用来传递敏感信息。这里所说的“安全”的含义仅仅是不作数据修改。从攻击的角度，无论是GET还是POST都不够安全，因为HTTP本身是**明文协议**。**每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body**。为了避免传输中数据被窃取，**必须做从客户端到服务器的端端加密。通行做法就是https** — 即用SSL协议协商出的密钥加密明文的http数据。

**▨ 响应报文**

&emsp;&emsp; HTTP协议响应是以字符文本的格式传输，具体包含四大部分：响应行、响应头、空行、响应数据。

![[../picture/Pasted image 20240514231232.png#pic_center|600]]

&emsp;&emsp;&emsp; ①  **响应行**：由**协议版本** 、**状态码**字段和 **HTTP协议版本** (HTTP-Version)字段3个字段组成，它们用空格分隔。

![[../picture/Pasted image 20240514233709.png#pic_center|640]]

##### 2.域名解析协议 - DNS协议
&emsp;&emsp; DNS (Domain Names System) 域名系统，
